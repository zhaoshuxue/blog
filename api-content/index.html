{"posts":[{"title":"Java面试问答——多线程","content":"什么是线程？ 线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位，可以使用多线程对进行运算提速。 创建线程池有几种方式？ 继承Thread类 实现Runnable接口，重写run（）方法 实现Callable接口，覆写call（）方法，有返回值 使用线程池创建 Java自带的线程池有哪些？ newCachedThreadPool，可缓存线程池 newFixedThreadPool，创建一个指定工作线程数量的线程池 newSingleThreadExecutor，单工作线程最大的特点是可保证顺序地执行各个任务 newScheduleThreadPool，创建一个定长的线程池，支持定时及周期性任务执行。 说说线程池的拒绝策略 AbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作。 CallerRunsPolicy 策略：只要线程池未关闭，该策略直接在调用者线程中，运行当前的被丢弃的任务。 DiscardOleddestPolicy策略： 该策略将丢弃最老的一个请求，也就是即将被执行的任务，并尝试再次提交当前任务。 DiscardPolicy策略：该策略默默的丢弃无法处理的任务，不予任何处理。 除了JDK默认为什么提供的四种拒绝策略，我们可以根据自己的业务需求去自定义拒绝策略，自定义的方式很简单，直接实现RejectedExecutionHandler接口即可。 比如Spring integration中就有一个自定义的拒绝策略CallerBlocksPolicy，将任务插入到队列中，直到队列中有空闲并插入成功的时候，否则将根据最大等待时间一直阻塞，直到超时。 ","link":"https://blog.funimg.top/post/java-mian-shi-wen-da-duo-xian-cheng/"},{"title":"祝大家520节日快乐","content":" ","link":"https://blog.funimg.top/post/zhu-da-jia-520-jie-ri-kuai-le/"},{"title":"SpringBoot的自动装配机制","content":"mark ","link":"https://blog.funimg.top/post/springboot-de-zi-dong-zhuang-pei-ji-zhi/"},{"title":"开工大吉，牛年牛气冲天","content":"加油 ","link":"https://blog.funimg.top/post/kai-gong-da-ji-niu-nian-niu-qi-chong-tian/"},{"title":"祝大家元旦快乐","content":"再见。2020 你好，2021 ","link":"https://blog.funimg.top/post/zhu-da-jia-yuan-dan-kuai-le/"},{"title":"使用Nginx解决VUE本地开发调用外部接口跨域的问题","content":"前端开发需要调用后台接口时经常遇到跨域的问题，一般是设置Chrome浏览器禁用安全模式， 在启动chrome命令后面加 --disable-web-security，最新的版本可能还需要加一个本地的存放chrome配置的文件夹，如下， --user-data-dir=C:\\MyChromeDevUserData 这种方式很不错，唯一的缺点就是有时候如果不是这种方式打开的Chrome，页面要进行跨域调试时需要关闭浏览器再用上边那种方式打开才行，这时如果已经打开了一堆网页可能就比较麻烦了。 现在介绍使用Nginx的方向代理机制来解决浏览器跨域的问题 首先假设前端VUE的端口是8080， 要调用的后台接口是：http://192.168.1.111:9090/mydemo/api/getList 因为浏览器的同源策略，所以这样必然产生了跨域。 由于VUE已经占用了前端的端口8080了，所以我们用Nginx只能再设置一个新的端口，这里暂定：8888 在nginx.conf文件 http{} 块里，添加下面的代码： server { listen 8888; server_name localhost; location ^~/mydemo/ { rewrite ^/(.*)$ /$1 break; proxy_pass http://192.168.1.111:9090/mydemo/; } location / { proxy_pass http://127.0.0.1:8080; } } location ^~/mydemo/ 一定要放在 location / 前面，这样所有访问后台的请求才会走这块的代理。 一般后台服务都会带着项目名，例如mydemo，或者加上固定的url路径前缀，主要是为了跟前端静态资源区分开来。 重启Nginx，访问 http://localhost:8888 即可。 这样就完全避免了跨域的问题，而且不限于Chrome了，使用IE、Firefox同样没有问题。 下面提供一种新的解决方式 什么是跨域 跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript实施的安全限制。 那么什么是同源策略 同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指&quot;协议+域名+端口&quot;三者相同，即便两个不同的域名指向同一个ip地址，也非同源。 下面列出了一些常见跨域场景 URL 说明 是否允许通信 http://www.google.com/a.js http://www.google.com/b.js 同一域名，不同文件或路径 允许 http://www.google.com/lab/c.js http://www.google.com:8000/a.js http://www.google.com/b.js 同一域名，不同端口 不允许 http://www.google.com/a.js https://www.google.com/b.js 同一域名，不同协议 不允许 http://www.google.com/a.js http://192.168.1.111/b.js 域名和域名对应相同ip 不允许 http://www.google.com/a.js http://x.google.com/b.js 主域相同，子域不同 不允许 http://google.com/c.js http://www.domain1.com/a.js http://www.domain2.com/b.js 不同域名 不允许 针对跨域，目前有很多解决方案 1、 通过jsonp跨域 2、 document.domain + iframe跨域 3、 location.hash + iframe 4、 window.name + iframe跨域 5、 postMessage跨域 6、 跨域资源共享（CORS） 7、 nginx代理跨域 8、 nodejs中间件代理跨域 9、 WebSocket协议跨域 下面我们就介绍一种目前主流的跨域解决方案——跨域资源共享（CORS） 什么是CORS CORS是一个W3C标准，全称是&quot;跨域资源共享&quot;（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。IE8+：IE8/9需要使用XDomainRequest对象来支持CORS。 整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 后端配置 只需要配置一个过滤器即可，如下： import org.apache.commons.lang3.StringUtils; import org.springframework.core.annotation.Order; import javax.servlet.*; import javax.servlet.annotation.WebFilter; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebFilter(urlPatterns = &quot;/*&quot;, filterName = &quot;corsFilter&quot;) @Order(1) public class CorsFilter implements Filter { @Override public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException { HttpServletResponse response = (HttpServletResponse) resp; HttpServletRequest request = (HttpServletRequest) req; // 解决跨域问题 if (StringUtils.isNotEmpty(request.getHeader(&quot;Origin&quot;))) { response.setHeader(&quot;Access-Control-Allow-Origin&quot;, request.getHeader(&quot;Origin&quot;)); response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); } else { response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); } response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, DELETE&quot;); response.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;36000&quot;); response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;accept,Access-Control-Request-Method,Access-Control-Request-Headers,Origin,token,x-requested-with, authorization, Content-Type, Authorization, credential, X-XSRF-TOKEN&quot;); response.setHeader(&quot;Access-Control-Expose-Headers&quot;, &quot;Content-Type, Authorization, credential, Content-Disposition&quot;); if (&quot;OPTIONS&quot;.equalsIgnoreCase(request.getMethod())) { response.setStatus(HttpServletResponse.SC_OK); } else { chain.doFilter(req, resp); } } } 前端配置 前端配置只需要把withCredentials设置为true即可。 1.原生ajax xhr.withCredentials = true; 2.vue框架 a.) axios设置： // 前端设置是否带cookie axios.defaults.withCredentials = true b.) vue-resource设置： Vue.http.options.credentials = true 这里假设后端服务地址为： 192.168.1.111:8080 我们需要配置一下hosts，（域名随便写） 192.168.1.111 server.google.com 这样访问 http://server.google.com:8080 也可能访问到你的后端服务了。 那么前端调用后端接口需要都写成 http://server.google.com:8080/+接口 这样的方式 访问前端也要用这种域名加端口的方式，比如本地启动了前端项目，端口是9090，那么也需要配置一下hosts， 127.0.0.1 front.google.com 就可以直接用 http://front.google.com:9090 访问前端页面了 也可以用下面这种配置方式直接设定vue启动后访问的url地址。 module.exports = { dev: { host: 'front.google.com', // can be overwritten by process.env.HOST port: 80, // can be overwritten by process.env.PORT, if port is in use, a free one will be determined ... } } 总结一下 1、配置hosts # 后端地址 192.168.1.111 server.google.com # 前端地址 127.0.0.1 front.google.com 2、前端调用后端接口需要用域名+端口方式，例如 http://server.google.com:8080 3、在浏览器访问前端页面也需要用域名+端口的方式，例如 http://front.google.com 4、只要保证配置的两个域名的二级域名一样就可以了，三级域名随便。 5、这种方式只需要配置一次，如果想访问不同环境的后端服务，只需要修改hosts配置就可以了。而且部署前后端分离时，只需要修改前端调用后端接口的配置即可。 ","link":"https://blog.funimg.top/post/biao-ti-ce-shi/"},{"title":"祝大家中秋节国庆节快乐","content":"㊗️朋友们双节快乐 ","link":"https://blog.funimg.top/post/zhu-da-jia-zhong-qiu-jie-guo-qing-jie-kuai-le/"},{"title":"Electron的安装与使用","content":"全局安装 Electron npm install electron -g 打包 全局安装打包神器electron-packager npm install electron-packager -g 最简打包 electron-packager . 打包成功，在当前目录下生成一个新的文件夹，里面生成一堆文件，点击其中的exe，即可启动桌面程序： electron-packager . &lt;可执行文件的文件名&gt; --win --out &lt;打包成的文件夹名&gt; --arch=&lt;x64位还是32位&gt; --version &lt;版本号&gt; --overwrite --ignore=node_modules 安装electron-builder npm install electron-builder -g 打包 electron-builder --win --x64 打包完成在dist目录生成以下文件： win-unpacked 免安装版 builder-effective-config.yaml 记录打包信息 my-project Setup 0.0.1.exe 安装文件，默认安装在c盘 my-project Setup 0.0.1.exe.blockmap 文件系统索引模式 ","link":"https://blog.funimg.top/post/pei-zhi/"},{"title":"Hexo搭建博客","content":"安装Hexo npm install hexo-cli -g npm install hexo-deployer-git --save 第二个命令表示安装 hexo 部署到 git page 的 deployer Hexo初始化 hexo init &lt;folder&gt; 运行 hexo g #生成或 hexo generate 生成的静态文件在 /***/public 目录下 hexo d #启动本地服务器 或者 hexo server,这一步之后就可以通过http://localhost:4000 查看了 配置 官网文档： https://hexo.io/zh-cn/docs/configuration 部署到Github 找到github的ssh链接 打开文件夹下的 _config.yml 文件 deploy: type: git repository: git@github.om:XXX.git branch: master 执行 hexo g -d 就会部署到github上了。 新建文章 hexo n &quot;文章标题&quot; hexo new &quot;文章名&quot; #新建文章 hexo new page &quot;页面名&quot; #新建页面 会在项目 \\Hexo\\source\\_posts 中生成 文章标题.md 文件， 也可以直接在 \\Hexo\\source\\_posts 目录下右键鼠标新建文本文档，改后缀为 .md 即可，这种方法比较方便。 更换主题 https://hexo.io/themes/ 把下载的主题文件夹hexo-theme-aero-dual放到 themes 目录下即可。 打开_config.yml配置文件，修改参数为：theme：hexo-theme-aero-dual （其他主题修改成相应名称即可） 使用Next主题 https://theme-next.org/ https://github.com/theme-next 主题安装 cd hexo # 进入博客根目录 git clone https://github.com/theme-next/hexo-theme-next themes/next Set theme in main Hexo root config _config.yml file: theme: next Next配置 编辑 /***/themes/next/_config.yml（其中***为博客根目录）文件 配置域名 编辑CNAME文件，内容为域名 常用简写 hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy 参考文章： https://blog.csdn.net/qq_36759224/article/details/82121420 ","link":"https://blog.funimg.top/post/0601/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://blog.funimg.top/post/hello-gridea/"}]}